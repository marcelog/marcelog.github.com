<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>Erlang Special Processes without behaviours</title>
<meta name="Author" content="Marcelo Gornstein"/>
<meta name="Keywords" content="erlang special process system message code change upgrade debug trace sys proc_lib handle_system_msg handle_debug supervisor supervision tree terminate spawn start link standard default otp behaviour"/>
<meta name="description" content="Tutorial that shows how to write a special process in erlang that will handle system messages and fits into an otp supervision tree"/>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="../images/favicon.ico" title="favicon" />
<link rel="stylesheet" href="../css/main.css" type="text/css" media="all" />
<link href='../dphighlighter/SyntaxHighlighter.css' rel='stylesheet' type='text/css' />
<!--[if IE]>
<link type="text/css" rel="stylesheet" media="screen" href="../css/fix-ie.css" />
<![endif]-->
<!--[if IE 6]>
<script type="text/javascript" src="../js/fix-png.js"></script>
<![endif]-->
<script type="text/javascript" src="http://apis.google.com/js/plusone.js"></script>
<script type="text/javascript" src="../js/lib/jquery-core.js"></script>
<script type="text/javascript" src="../js/main.js"></script>
</head>
<body>
<div id="wrapper">
  <div id="top">
    <!-- <a class="logo" href="index.html">Marcelo G</a>-->
    <ul id="nav">
      <li><a href="../index.html"><span>Home</span></a></li>
      <!-- <li><a href="../about.html"><span>About</span></a></li> -->
      <li class="active"><a href="articles.html"><span>Articles</span></a></li>
      <li><a href="../software.html"><span>Software</span></a></li>
      <li><a href="mailto:marcelog@gmail.com"><span>Contact</span></a></li>
    </ul>
  </div>
  <div class="header">
  	<div class="line">
      <h1>Articles</h1>
      <div class="social-network">
       <a href="mailto:marcelog@gmail.com" class="icon-email" title="Email">Email</a>
       <g:plusone></g:plusone>
      </div>
   	</div>
    <div class="breadcrumb">You are here &nbsp;&raquo;&nbsp; <a href="../index.html">Home Page</a>  &nbsp;&raquo;&nbsp;  <a href="articles.html">Articles</a>  &nbsp;&raquo;&nbsp;  Erlang Special Processes without behaviours</div>
  </div>
  <div class="main-outer">
  	<div class="main-inner">
    	<div class="main">
      	<div class="line">
          <div id="content">
            <div class="mod simple article-detail-style">
              <span class="top"><span class="tl"></span><span class="tr"></span></span>
              <div class="inner set-height-1">
                <h2>Erlang Special Processes without behaviours</h2>
                <div class="hr-1"><hr /></div>
  <p>
<b>NOTE</b>: This is the translation of the <a href="http://erlang.org.ar/ProcesosEspeciales">original article</a> I wrote in spanish for the
wiki of <a href="http://erlang.org.ar/">Erlang Argentina</a>.
</p>
<h3>Introduction</h3>
<p>
OTP has (in its <a href="http://www.erlang.org/doc/design_principles/des_princ.html">design principles</a>), things like <a href="http://learnyousomeerlang.com/what-is-otp#the-common-process-abstracted">behaviours</a>, <a href="http://www.erlang.org/doc/design_principles/applications.html" >applications</a>,
<a href="http://www.erlang.org/doc/design_principles/release_structure.html">releases</a>, and <a href="http://www.erlang.org/doc/design_principles/sup_princ.html" >supervision trees</a>.
If we zoom into the latter, we'll find <a href="http://www.erlang.org/doc/man/supervisor.html">supervisors</a>, which supervise <a href="http://www.erlang.org/doc/reference_manual/processes.html">processes</a>, that can also
be supervisors themselves.
</p>
<p>
Now, processes can be "common processes" or "special processes". A common process is not integrated with OTP, it cant be supervised (in a standard way), and wont comply/attend to system messages, making process
termination, hot code upgrades and the like a very hard task (if not impossible).
A special process complies, <a href="http://www.erlang.org/doc/design_principles/spec_proc.html">by definition</a> with a specification that makes it compatible with all the rules of an OTP environment. Let's now see what this
spec is all about.
</p>
<h3>Nothing new, actually</h3>
<p>
As a matter of fact, we deal with special processes a lot, even without knowing it. For example, when we choose to implement a behaviour (like supervisor, gen_server, etc), we are actually coding "inside" a special process. Yes, behaviours are special processes,
if we look under the hood (see Appendix, at the end of the article), we'll spot a special process just like the one we'll see in the example code.
</p>
<p>
The main difference between a common process and a special process, is that the special process receives the <a href="http://www.erlang.org/doc/man/sys.html">system messages</a> and
reacts upon them. A special process is also <a href="http://www.erlang.org/doc/man/proc_lib.html#start_link-3">started in a specific way</a>, and all these
properties allows a process to fit right into supervision trees, and to support features such as hot-code upgrades, debugging, etc.
</p>
<h3>What are they good for?</h3>
<p>
Knowing how a special process works (and how it should be implemented) is fun, and gives a little "low level" background (which is always good), but it's
particular useful when we need a process to behave different than the standard provided behaviours (like gen_server, etc). There is a handful of cases where
coding your own special process is the best solution. But knowing about them means to be sure that your code wont violate the OTP design principles.
</p>
<p>
And, it might allow you to impress your friends at the parties (well, if any of you goes to a party where people can actually be impressed by such things, please drop me a line!).
</p>
<h3>The code (simpleproc.erl)</h3>
<p>
The following code is a <a href="https://github.com/basho/rebar">rebar</a> template, which is also available at
<a href="https://github.com/marcelog/rebar-spec-proc-tpl">GitHub</a>. I though it would be best to show you the
code first, explaining some of the stuff in the code comments (and pointing out the most useful manual links) and
then go ahead with a little deeper explanation.
</p>
<pre name="code" class="php">
%%% This is a special process. A special process is aware of system
%%% messages and also implements some standard functions needed (and
%%% standarized) in an OTP environment, so it can be supervised
%%% (started/stop), upgraded in a hot-upgrade fashion, etc.
%%%
%%% See http://www.erlang.org/doc/design_principles/spec_proc.html
%%% For system messages, see: http://www.erlang.org/doc/man/sys.html
-module({{id}}).
%%-------------------------------------------------------------------
%% API Function Exports
%%-------------------------------------------------------------------
-export([start_link/0, init/1]).

%%-------------------------------------------------------------------
%% Required OTP Exports
%%-------------------------------------------------------------------
-export([
    system_code_change/4, system_continue/3,
    system_terminate/4, write_debug/3
]).

%%-------------------------------------------------------------------
%% API Function Definitions
%%-------------------------------------------------------------------
%% @doc Starts a new process synchronously. Spawns the process and
%%% waits for it to start.
%% See http://www.erlang.org/doc/man/proc_lib.html
start_link() ->
    proc_lib:start_link(?MODULE, init, [self()]).

%%-------------------------------------------------------------------
%% API Function Definitions
%%-------------------------------------------------------------------
%% @doc Notifies the parent of a successful start and then runs the
%% main loop. When the process has started, it must call
%% init_ack(Parent,Ret) or init_ack(Ret), where Parent is the
%% process that evaluates this function (see start_link/0 above).
%% At this time, Ret is returned.
init(Parent) ->
    register(?MODULE, self()),
    Debug = sys:debug_options([]),
    proc_lib:init_ack(Parent, {ok, self()}),
    loop(Parent, Debug, []).

%%-------------------------------------------------------------------
%% Internal Functions
%%-------------------------------------------------------------------
%% @doc Our main loop, designed to handle system messages.
loop(Parent, Debug, State) ->
    receive
        {system, From, Request} ->
            sys:handle_system_msg(
                Request, From, Parent, ?MODULE, Debug, State
            );
        Msg ->
            % Let's print unknown messages.
            sys:handle_debug(
                Debug, fun ?MODULE:write_debug/3, ?MODULE, {in, Msg}
            ),
            loop(Parent, Debug, State)
    end.

%% @doc Called by sys:handle_debug().
write_debug(Dev, Event, Name) ->
    io:format(Dev, "~p event = ~p~n", [Name, Event]).

%% @doc http://www.erlang.org/doc/man/sys.html#Mod:system_continue-3
system_continue(Parent, Debug, State) ->
    io:format("Continue!~n"),
    loop(Parent, Debug, State).

%% @doc http://www.erlang.org/doc/man/sys.html#Mod:system_terminate-4
system_terminate(Reason, _Parent, _Debug, _State) ->
    io:format("Terminate!~n"),
    exit(Reason).

%% @doc http://www.erlang.org/doc/man/sys.html#Mod:system_code_change-4
system_code_change(State, _Module, _OldVsn, _Extra) ->
    io:format("Changed code!~n"),
    {ok, State}.
</pre>
<h3>How it works</h3>
<p>
In this particular case, I've only implementes start_link, but <a href="http://www.erlang.org/doc/man/proc_lib.html">proc_lib</a> actually gives us a couple of options to
start a process:
</p>
<ul>
<li><b>start_link/3,4,5</b> and <b>start/3,4,5</b> for a sync startup, where the supervisor will wait until the newly created process
calls <a href="http://www.erlang.org/doc/man/proc_lib.html#init_ack-1">proc_lib:init_ack/1,2</a>.
</li>
<li>
<b>spawn_link/1,2,3,4</b> and <b>spawn/1,2,3,4</b> for an asynchronous start.
</li>
</ul>
<p>
When we invoke simpleproc:start_link/0 (for example from a supervisor), it will call proc_lib:start_link/3, which in turns, calls
simpleproc:init/1. This one will wait for a message that indicates a successful or failed init (sent by invoking proc_lib:init_ack/1,2). This is
effectively a synchronous start.
</p>
<p>
As soon as the supervisor knows that the process started, the main loop is invoked.
</p>
<p>
The main loop receives the system messages (which are in the form {system, From, ...}) and process them by
calling <a href="http://www.erlang.org/doc/man/sys.html#handle_system_msg-6">sys:handle_system_msg/6</a>. This function
DOES NOT RETURN, and will invoke <b>system_code_change</b>, <b>system_terminate</b>, <b>system_continue</b>.
</p>
<p>
<b>NOTE</b>: See that we don't call simpleproc:loop after calling sys:handle_system_msg/6, because this function
will never return, but will call simpleproc:system_continue/3. The current process state will be passed from
sys:handle_system_msg/6 to simpleproc:system_continue/3, which will return to the main loop.
</p>
<p>
In the "Appendix" section, you can see the implementation of the actual behaviours distributed with OTP. As you can see,
their code is pretty similar to the one shown here, except that they reuse code that "lives" in the <b>gen</b> module.
</p>
<h3>Tracing and Debugging</h3>
<p>
Another requirement for special process is to support enabling and disabling debug output in the console. To comply with this, our
debug should go through <a href="http://www.erlang.org/doc/man/sys.html#handle_debug-4">sys:handle_debug/4</a>. In the
example code, we do this when receiving an unknown message (the last receive clause). sys:handle_debug/4 will invoke
the function we pass in the 3rd argument (in this case, simpleproc:write_debug/3), which will actually print the
debug messages in the console.
</p>
<p>
The 4th argument in sys:handle_debug/4, is the system event we want to log. Actually, it's up to the user (us) to
define system events, but usually incoming and outgoing messages are represented as tuples, in the form
{in,Msg[,From]} and {out,Msg,To}, respectively.
</p>
<p>
To give this a try, we use <a href="http://www.erlang.org/doc/man/sys.html#trace-2">sys:trace/2</a>, so we can enable debug for
our little module:
</p>
<pre name="code" class="php">
1> c(simpleproc).
{ok,simpleproc}
2> {ok, Pid} = simpleproc:start_link().
{ok,<0.38.0>}
3> Pid ! hi.
hi
4> sys:trace(simpleproc, true).
Continue!
ok
5> Pid ! hi.
simpleproc event = {in, hi}
hi
6> sys:trace(simpleproc, false).
Continue!
ok
7> Pid ! hi.
hi
</pre>
<p>
In our case, we use {in, Msg} as the system event, which is standarized.
</p>
<p>
<b>NOTE</b>: The debug options are initialized in simpleproc:init/1, by calling <a href="http://www.erlang.org/doc/man/sys.html#debug_options-1">sys:debug_options/1</a>,
these are keep along the code, and can be changed by calling sys:trace/2,3 and sys:statistics/2,3.
</p>
<h3>Code change</h3>
<p>
<b>simpleproc:system_code_change/4</b> is invoked by sys:handle_system_msg/6 when a code change is required. This function
must convert the process actual state (the State argument) to the new structure. What follows is an example of hot-code upgrade,
by using <a href="http://www.erlang.org/doc/man/sys.html#change_code-4">sys:change_code/4</a>:
</p>
<pre name="code" class="php">
1> c(simpleproc).
{ok,simpleproc}
2> {ok, Pid} = simpleproc:start_link().
{ok,<0.38.0>}
3> sys:suspend(Pid).
ok
4> c(simpleproc).
{ok,simpleproc}
5> sys:change_code(simpleproc, simpleproc, [], []).
Changed code!
ok
6> sys:resume(simpleproc).
Continue!
ok
</pre>

<h3>Conclusion</h3>
<p>
Well that wasn't so hard, was it? :D With a few lines of code, and (relatively) few concepts, we can now
create our own processes, that support fault tolerance and high availability, and mainly, that really fit
into the normal activity of our OTP applications, just like a gen_server, gen_fsm, supervisor, etc. :) A skill
useful in a very few scenarios, but nevertheless, will worth a million bucks when the moment comes!
</p>
<h3>Appendix</h3>
<p>
What follows is the source code for the behaviours distributed with OTP. Only the relevant code is shown, just
to see how the pro's are doing it :)
</p>
<p>
At the end of the appendix, the <b>gen</b> module is shown, where some code that calls the proc_lib function
"lives" and is reused from the behaviours.
</p>
<h3>lib/stdlib/src/gen_server.erl</h3>

<b>Note</b>: Supervisor IS a gen_server.

<pre name="code" class="php">
%%%  -----------------------------------------------------------------
%%% Starts a generic server.
%%% start(Mod, Args, Options)
%%% start(Name, Mod, Args, Options)
%%% start_link(Mod, Args, Options)
%%% start_link(Name, Mod, Args, Options) where:
%%%    Name ::= {local, atom()} | {global, atom()} | {via, atom(), term()}
%%%    Mod  ::= atom(), callback module implementing the 'real' server
%%%    Args ::= term(), init arguments (to Mod:init/1)
%%%    Options ::= [{timeout, Timeout} | {debug, [Flag]}]
%%%      Flag ::= trace | log | {logfile, File} | statistics | debug
%%%          (debug == log && statistics)
%%% Returns: {ok, Pid} |
%%%          {error, {already_started, Pid}} |
%%%          {error, Reason}
%%% -----------------------------------------------------------------
start(Mod, Args, Options) ->
    gen:start(?MODULE, nolink, Mod, Args, Options).

start(Name, Mod, Args, Options) ->
    gen:start(?MODULE, nolink, Name, Mod, Args, Options).

start_link(Mod, Args, Options) ->
    gen:start(?MODULE, link, Mod, Args, Options).

start_link(Name, Mod, Args, Options) ->
    gen:start(?MODULE, link, Name, Mod, Args, Options).


%%% ---------------------------------------------------
%%% Initiate the new process.
%%% Register the name using the Rfunc function
%%% Calls the Mod:init/Args function.
%%% Finally an acknowledge is sent to Parent and the main
%%% loop is entered.
%%% ---------------------------------------------------
init_it(Starter, self, Name, Mod, Args, Options) ->
    init_it(Starter, self(), Name, Mod, Args, Options);
init_it(Starter, Parent, Name0, Mod, Args, Options) ->
    Name = name(Name0),
    Debug = debug_options(Name, Options),
    case catch Mod:init(Args) of
    {ok, State} ->
        proc_lib:init_ack(Starter, {ok, self()}),
        loop(Parent, Name, State, Mod, infinity, Debug);
    {ok, State, Timeout} ->
        proc_lib:init_ack(Starter, {ok, self()}),
        loop(Parent, Name, State, Mod, Timeout, Debug);
    {stop, Reason} ->
        %% For consistency, we must make sure that the
        %% registered name (if any) is unregistered before
        %% the parent process is notified about the failure.
        %% (Otherwise, the parent process could get
        %% an 'already_started' error if it immediately
        %% tried starting the process again.)
        unregister_name(Name0),
        proc_lib:init_ack(Starter, {error, Reason}),
        exit(Reason);
    ignore ->
        unregister_name(Name0),
        proc_lib:init_ack(Starter, ignore),
        exit(normal);
    {'EXIT', Reason} ->
        unregister_name(Name0),
        proc_lib:init_ack(Starter, {error, Reason}),
        exit(Reason);
    Else ->
        Error = {bad_return_value, Else},
        proc_lib:init_ack(Starter, {error, Error}),
        exit(Error)
    end.

%%% ---------------------------------------------------
%%% The MAIN loop.
%%% ---------------------------------------------------
loop(Parent, Name, State, Mod, hibernate, Debug) ->
    proc_lib:hibernate(?MODULE,wake_hib,[Parent, Name, State, Mod, Debug]);
loop(Parent, Name, State, Mod, Time, Debug) ->
    Msg = receive
          Input ->
            Input
      after Time ->
          timeout
      end,
    decode_msg(Msg, Parent, Name, State, Mod, Time, Debug, false).

%%-----------------------------------------------------------------
%% Callback functions for system messages handling.
%%-----------------------------------------------------------------
system_continue(Parent, Debug, [Name, State, Mod, Time]) ->
    loop(Parent, Name, State, Mod, Time, Debug).

-spec system_terminate(_, _, _, [_]) -> no_return().

system_terminate(Reason, _Parent, Debug, [Name, State, Mod, _Time]) ->
    terminate(Reason, Name, [], Mod, State, Debug).

system_code_change([Name, State, Mod, Time], _Module, OldVsn, Extra) ->
    case catch Mod:code_change(OldVsn, State, Extra) of
    {ok, NewState} -> {ok, [Name, NewState, Mod, Time]};
    Else -> Else
    end.

%%% ---------------------------------------------------
%%% Terminate the server.
%%% ---------------------------------------------------

terminate(Reason, Name, Msg, Mod, State, Debug) ->
    case catch Mod:terminate(Reason, State) of
    {'EXIT', R} ->
        error_info(R, Name, Msg, State, Debug),
        exit(R);
    _ ->
        case Reason of
        normal ->
            exit(normal);
        shutdown ->
            exit(shutdown);
        {shutdown,_}=Shutdown ->
            exit(Shutdown);
        _ ->
            FmtState =
            case erlang:function_exported(Mod, format_status, 2) of
                true ->
                Args = [get(), State],
                case catch Mod:format_status(terminate, Args) of
                    {'EXIT', _} -> State;
                    Else -> Else
                end;
                _ ->
                State
            end,
            error_info(Reason, Name, Msg, FmtState, Debug),
            exit(Reason)
        end
    end.

decode_msg(Msg, Parent, Name, State, Mod, Time, Debug, Hib) ->
    case Msg of
    {system, From, Req} ->
        sys:handle_system_msg(Req, From, Parent, ?MODULE, Debug,
                  [Name, State, Mod, Time], Hib);
    {'EXIT', Parent, Reason} ->
        terminate(Reason, Name, Msg, Mod, State, Debug);
    _Msg when Debug =:= [] ->
        handle_msg(Msg, Parent, Name, State, Mod);
    _Msg ->
        Debug1 = sys:handle_debug(Debug, fun print_event/3,
                      Name, {in, Msg}),
        handle_msg(Msg, Parent, Name, State, Mod, Debug1)
    end.
</pre>

<h3>lib/stdlib/src/gen_fsm.erl</h3>
<pre name="code" class="php">
%%% ---------------------------------------------------
%%% Starts a generic state machine.
%%% start(Mod, Args, Options)
%%% start(Name, Mod, Args, Options)
%%% start_link(Mod, Args, Options)
%%% start_link(Name, Mod, Args, Options) where:
%%%    Name ::= {local, atom()} | {global, atom()} | {via, atom(), term()}
%%%    Mod  ::= atom(), callback module implementing the 'real' fsm
%%%    Args ::= term(), init arguments (to Mod:init/1)
%%%    Options ::= [{debug, [Flag]}]
%%%      Flag ::= trace | log | {logfile, File} | statistics | debug
%%%          (debug == log && statistics)
%%% Returns: {ok, Pid} |
%%%          {error, {already_started, Pid}} |
%%%          {error, Reason}
%%% ---------------------------------------------------
start(Mod, Args, Options) ->
    gen:start(?MODULE, nolink, Mod, Args, Options).

start(Name, Mod, Args, Options) ->
    gen:start(?MODULE, nolink, Name, Mod, Args, Options).

start_link(Mod, Args, Options) ->
    gen:start(?MODULE, link, Mod, Args, Options).

start_link(Name, Mod, Args, Options) ->
    gen:start(?MODULE, link, Name, Mod, Args, Options).

%%% ---------------------------------------------------
%%% Initiate the new process.
%%% Register the name using the Rfunc function
%%% Calls the Mod:init/Args function.
%%% Finally an acknowledge is sent to Parent and the main
%%% loop is entered.
%%% ---------------------------------------------------
init_it(Starter, self, Name, Mod, Args, Options) ->
    init_it(Starter, self(), Name, Mod, Args, Options);
init_it(Starter, Parent, Name0, Mod, Args, Options) ->
    Name = name(Name0),
    Debug = gen:debug_options(Options),
    case catch Mod:init(Args) of
    {ok, StateName, StateData} ->
        proc_lib:init_ack(Starter, {ok, self()}),
        loop(Parent, Name, StateName, StateData, Mod, infinity, Debug);
    {ok, StateName, StateData, Timeout} ->
        proc_lib:init_ack(Starter, {ok, self()}),
        loop(Parent, Name, StateName, StateData, Mod, Timeout, Debug);
    {stop, Reason} ->
        unregister_name(Name0),
        proc_lib:init_ack(Starter, {error, Reason}),
        exit(Reason);
    ignore ->
        unregister_name(Name0),
        proc_lib:init_ack(Starter, ignore),
        exit(normal);
    {'EXIT', Reason} ->
        unregister_name(Name0),
        proc_lib:init_ack(Starter, {error, Reason}),
        exit(Reason);
    Else ->
        Error = {bad_return_value, Else},
        proc_lib:init_ack(Starter, {error, Error}),
        exit(Error)
    end.
%%-----------------------------------------------------------------
%% The MAIN loop
%%-----------------------------------------------------------------
loop(Parent, Name, StateName, StateData, Mod, hibernate, Debug) ->
    proc_lib:hibernate(?MODULE,wake_hib,
               [Parent, Name, StateName, StateData, Mod,
            Debug]);
loop(Parent, Name, StateName, StateData, Mod, Time, Debug) ->
    Msg = receive
          Input ->
            Input
      after Time ->
          {'$gen_event', timeout}
      end,
    decode_msg(Msg,Parent, Name, StateName, StateData, Mod, Time, Debug, false).

wake_hib(Parent, Name, StateName, StateData, Mod, Debug) ->
    Msg = receive
          Input ->
          Input
      end,
    decode_msg(Msg, Parent, Name, StateName, StateData, Mod, hibernate, Debug, true).

decode_msg(Msg,Parent, Name, StateName, StateData, Mod, Time, Debug, Hib) ->
    case Msg of
        {system, From, Req} ->
        sys:handle_system_msg(Req, From, Parent, ?MODULE, Debug,
                  [Name, StateName, StateData, Mod, Time], Hib);
    {'EXIT', Parent, Reason} ->
        terminate(Reason, Name, Msg, Mod, StateName, StateData, Debug);
    _Msg when Debug =:= [] ->
        handle_msg(Msg, Parent, Name, StateName, StateData, Mod, Time);
    _Msg ->
        Debug1 = sys:handle_debug(Debug, fun print_event/3,
                      {Name, StateName}, {in, Msg}),
        handle_msg(Msg, Parent, Name, StateName, StateData,
               Mod, Time, Debug1)
    end.

%%-----------------------------------------------------------------
%% Callback functions for system messages handling.
%%-----------------------------------------------------------------
system_continue(Parent, Debug, [Name, StateName, StateData, Mod, Time]) ->
    loop(Parent, Name, StateName, StateData, Mod, Time, Debug).

-spec system_terminate(term(), _, _, [term(),...]) -> no_return().

system_terminate(Reason, _Parent, Debug,
         [Name, StateName, StateData, Mod, _Time]) ->
    terminate(Reason, Name, [], Mod, StateName, StateData, Debug).
system_code_change([Name, StateName, StateData, Mod, Time],
           _Module, OldVsn, Extra) ->
    case catch Mod:code_change(OldVsn, StateName, StateData, Extra) of
    {ok, NewStateName, NewStateData} ->
        {ok, [Name, NewStateName, NewStateData, Mod, Time]};
    Else -> Else
    end.

terminate(Reason, Name, Msg, Mod, StateName, StateData, Debug) ->
    case catch Mod:terminate(Reason, StateName, StateData) of
    {'EXIT', R} ->
        error_info(R, Name, Msg, StateName, StateData, Debug),
        exit(R);
    _ ->
        case Reason of
        normal ->
            exit(normal);
        shutdown ->
            exit(shutdown);
        {shutdown,_}=Shutdown ->
            exit(Shutdown);
        _ ->
                    FmtStateData =
                        case erlang:function_exported(Mod, format_status, 2) of
                            true ->
                                Args = [get(), StateData],
                                case catch Mod:format_status(terminate, Args) of
                                    {'EXIT', _} -> StateData;
                                    Else -> Else
                                end;
                            _ ->
                                StateData
                        end,
            error_info(Reason,Name,Msg,StateName,FmtStateData,Debug),
            exit(Reason)
        end
    end.

</pre>

<h3>lib/stdlib/src/gen_event.erl</h3>
<pre name="code" class="php">
%%---------------------------------------------------------------------------

-define(NO_CALLBACK, 'no callback module').

-spec start() -> start_ret().
start() ->
    gen:start(?MODULE, nolink, ?NO_CALLBACK, [], []).

-spec start(emgr_name()) -> start_ret().
start(Name) ->
    gen:start(?MODULE, nolink, Name, ?NO_CALLBACK, [], []).

-spec start_link() -> start_ret().
start_link() ->
    gen:start(?MODULE, link, ?NO_CALLBACK, [], []).

-spec start_link(emgr_name()) -> start_ret().
start_link(Name) ->
    gen:start(?MODULE, link, Name, ?NO_CALLBACK, [], []).

%% -spec init_it(pid(), 'self' | pid(), emgr_name(), module(), [term()], [_]) ->
init_it(Starter, self, Name, Mod, Args, Options) ->
    init_it(Starter, self(), Name, Mod, Args, Options);
init_it(Starter, Parent, Name0, _, _, Options) ->
    process_flag(trap_exit, true),
    Debug = gen:debug_options(Options),
    proc_lib:init_ack(Starter, {ok, self()}),
    Name = name(Name0),
    loop(Parent, Name, [], Debug, false).
loop(Parent, ServerName, MSL, Debug, true) ->
     proc_lib:hibernate(?MODULE, wake_hib, [Parent, ServerName, MSL, Debug]);
loop(Parent, ServerName, MSL, Debug, _) ->
    fetch_msg(Parent, ServerName, MSL, Debug, false).

fetch_msg(Parent, ServerName, MSL, Debug, Hib) ->
    receive
    {system, From, Req} ->
        sys:handle_system_msg(Req, From, Parent, ?MODULE, Debug,
                  [ServerName, MSL, Hib],Hib);
    {'EXIT', Parent, Reason} ->
        terminate_server(Reason, Parent, MSL, ServerName);
    Msg when Debug =:= [] ->
        handle_msg(Msg, Parent, ServerName, MSL, []);
    Msg ->
        Debug1 = sys:handle_debug(Debug, fun print_event/3,
                      ServerName, {in, Msg}),
        handle_msg(Msg, Parent, ServerName, MSL, Debug1)
    end.
terminate_server(Reason, Parent, MSL, ServerName) ->
    stop_handlers(MSL, ServerName),
    do_unlink(Parent, MSL),
    exit(Reason).
%% First terminate the supervised (if exists) handlers and
%% then inform other handlers.
%% We do not know if any handler really is interested but it
%% may be so !
handle_exit(From, Reason, MSL, SName) ->
    MSL1 = terminate_supervised(From, Reason, MSL, SName),
    {_,MSL2}=server_notify({'EXIT', From, Reason}, handle_info, MSL1, SName),
    MSL2.

terminate_supervised(Pid, Reason, MSL, SName) ->
    F = fun(Ha) when Ha#handler.supervised =:= Pid ->
        do_terminate(Ha#handler.module,
                 Ha,
                 {stop,Reason},
                 Ha#handler.state,
                 {parent_terminated, {Pid,Reason}},
                 SName,
                 shutdown),
        false;
       (_) ->
        true
    end,
    lists:filter(F, MSL).

%%-----------------------------------------------------------------
%% Callback functions for system messages handling.
%%-----------------------------------------------------------------
system_continue(Parent, Debug, [ServerName, MSL, Hib]) ->
    loop(Parent, ServerName, MSL, Debug, Hib).

-spec system_terminate(_, _, _, [_]) -> no_return().
system_terminate(Reason, Parent, _Debug, [ServerName, MSL, _Hib]) ->
    terminate_server(Reason, Parent, MSL, ServerName).

%%-----------------------------------------------------------------
%% Module here is sent in the system msg change_code.  It specifies
%% which module should be changed.
%%-----------------------------------------------------------------
system_code_change([ServerName, MSL, Hib], Module, OldVsn, Extra) ->
    MSL1 = lists:zf(fun(H) when H#handler.module =:= Module ->
                {ok, NewState} =
                Module:code_change(OldVsn,
                           H#handler.state, Extra),
                {true, H#handler{state = NewState}};
               (_) -> true
            end,
            MSL),
    {ok, [ServerName, MSL1, Hib]}.
</pre>

<h3>lib/stdlib/src/gen.erl</h3>
<pre name="code" class="php">
%%-----------------------------------------------------------------
%% Starts a generic process.
%% start(GenMod, LinkP, Mod, Args, Options)
%% start(GenMod, LinkP, Name, Mod, Args, Options)
%%    GenMod = atom(), callback module implementing the 'real' fsm
%%    LinkP = link | nolink
%%    Name = {local, atom()} | {global, term()} | {via, atom(), term()}
%%    Args = term(), init arguments (to Mod:init/1)
%%    Options = [{timeout, Timeout} | {debug, [Flag]} | {spawn_opt, OptionList}]
%%      Flag = trace | log | {logfile, File} | statistics | debug
%%          (debug == log && statistics)
%% Returns: {ok, Pid} | ignore |{error, Reason} |
%%          {error, {already_started, Pid}} |
%%    The 'already_started' is returned only if Name is given
%%-----------------------------------------------------------------

-spec start(module(), linkage(), emgr_name(), module(), term(), options()) ->
    start_ret().

start(GenMod, LinkP, Name, Mod, Args, Options) ->
    case where(Name) of
    undefined ->
        do_spawn(GenMod, LinkP, Name, Mod, Args, Options);
    Pid ->
        {error, {already_started, Pid}}
    end.

-spec start(module(), linkage(), module(), term(), options()) -> start_ret().

start(GenMod, LinkP, Mod, Args, Options) ->
    do_spawn(GenMod, LinkP, Mod, Args, Options).

%%-----------------------------------------------------------------
%% Spawn the process (and link) maybe at another node.
%% If spawn without link, set parent to ourselves 'self'!!!
%%-----------------------------------------------------------------
do_spawn(GenMod, link, Mod, Args, Options) ->
    Time = timeout(Options),
    proc_lib:start_link(?MODULE, init_it,
            [GenMod, self(), self(), Mod, Args, Options],
            Time,
            spawn_opts(Options));
do_spawn(GenMod, _, Mod, Args, Options) ->
    Time = timeout(Options),
    proc_lib:start(?MODULE, init_it,
           [GenMod, self(), self, Mod, Args, Options],
           Time,
           spawn_opts(Options)).

do_spawn(GenMod, link, Name, Mod, Args, Options) ->
    Time = timeout(Options),
    proc_lib:start_link(?MODULE, init_it,
            [GenMod, self(), self(), Name, Mod, Args, Options],
            Time,
            spawn_opts(Options));
do_spawn(GenMod, _, Name, Mod, Args, Options) ->
    Time = timeout(Options),
    proc_lib:start(?MODULE, init_it,
           [GenMod, self(), self, Name, Mod, Args, Options],
           Time,
           spawn_opts(Options)).

%%-----------------------------------------------------------------
%% Initiate the new process.
%% Register the name using the Rfunc function
%% Calls the Mod:init/Args function.
%% Finally an acknowledge is sent to Parent and the main
%% loop is entered.
%%-----------------------------------------------------------------
init_it(GenMod, Starter, Parent, Mod, Args, Options) ->
    init_it2(GenMod, Starter, Parent, self(), Mod, Args, Options).

init_it(GenMod, Starter, Parent, Name, Mod, Args, Options) ->
    case name_register(Name) of
    true ->
        init_it2(GenMod, Starter, Parent, Name, Mod, Args, Options);
    {false, Pid} ->
        proc_lib:init_ack(Starter, {error, {already_started, Pid}})
    end.

init_it2(GenMod, Starter, Parent, Name, Mod, Args, Options) ->
    GenMod:init_it(Starter, Parent, Name, Mod, Args, Options).

</pre>

              </div>
            </div>
            <div class="mod view-more">
              <div class="inner">
                <a href="articles.html">Read Other Articles</a>
              </div>
              <span class="bottom"><span class="bl"></span><span class="br"></span></span>
            </div>
          </div>
          <div id="sidebar" class="highlight articles-style original">
            <div class="mod simple">
              <span class="top"><span class="tl"></span><span class="tr"></span></span>
              <div class="inner set-height-1">
              	<h2>Related Articles</h2>
                <div class="hr-1"><hr /></div>
                <ul class="quick-list">
                  <li><a href="erlang_persistence_entities.html">Persisting your entities in Erlang</a></li>
                  <li><a href="erlang_rebar_coverage_on_subdirectories.html">Common Test: Code coverage on subdirectories</a></li>
                  <li><a href="erlang_websocket_server_cowboy_tutorial.html">Erlang Websocket Server using Cowboy</a></li>
                  <li><a href="erlang_rebar_generate_code_coverage_eunit_tests.html">How to generate code coverage for eunit tests when using rebar</a></li>
                  <li><a href="erlang_rebar_run_eunit_skip_dependencies.html">How to skip compile and eunit test for dependencies in rebar</a></li>
                </ul>
                <div class="google-ads">
                    <script type="text/javascript">
                    google_ad_client = "ca-pub-6947936742546167";
                    /* 9 */
                    google_ad_slot = "8617829895";
                    google_ad_width = 250;
                    google_ad_height = 250;
                    //-->
                    </script>
                    <script type="text/javascript"
                    src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
                    </script>
                </div>
              </div>
              <span class="bottom"><span class="bl"></span><span class="br"></span></span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="footer">
  	<!-- <p>&copy; 2010 Marcelo G. All Rights Reserved. Website design by <a href="http://Digitallabs.tv" target="_blank">Digitallabs.tv</a></p> -->
    <address>Email: <a href="mailto:marcelog@gmail.com">marcelog@gmail.com</a></address>
  </div>
</div>

<!-- config SyntaxHighlighter -->
<script src='../dphighlighter/shCore.js' type='text/javascript'></script>
<script src='../dphighlighter/shBrushPhp.js' type='text/javascript'></script>
<script src='../dphighlighter/shBrushXml.js' type='text/javascript'></script>
<script src='../dphighlighter/shBrushJScript.js' type='text/javascript'></script>
<script src='../dphighlighter/shBrushCss.js' type='text/javascript'></script>
<script language="javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '../dphighlighter/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code');
</script>
  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21070993-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>